% me=0 student solutions (ps file), me=1 - my solutions (sol file),
% me=2 - assignment (hw file)
\def\me{0} \def\num{3} %homework number

\def\due{Tuesday, September 27} %due date

\def\course{CSCI-UA.0310-â€‹001/002 Basic Algorithms} 
%course name, changed only once

% **** INSERT YOUR NAME HERE ****
\def\name{Name}

% **** INSERT YOUR NETID HERE ****
\def\netid{ijs253}

% **** INSERT NETIDs OF YOUR COLLABORATORS HERE ****
\def\collabs{NetID1, NetID2}


\iffalse

INSTRUCTIONS: replace # by the homework number.  (if this is not
ps#.tex, use the right file name)

Clip out the ********* INSERT HERE ********* bits below and insert
appropriate LaTeX code.  There is a section below for student macros.
It is not recommended to change any other parts of the code.


\fi
%

\documentclass[11pt]{article}


% ==== Packages ====
\usepackage{amsfonts,amsmath}
\usepackage{latexsym}
\usepackage{graphicx}

 \setlength{\oddsidemargin}{.0in} \setlength{\evensidemargin}{.0in}
 \setlength{\textwidth}{6.5in} \setlength{\topmargin}{-0.4in}
\setlength{\footskip}{1in} \setlength{\textheight}{8.5in}

\newcommand{\handout}[5]{
\renewcommand{\thepage}{#1, Page \arabic{page}}
  \noindent
  \begin{center}
    \framebox{ \vbox{ \hbox to 5.78in { {\bf \course} \hfill #2 }
        \vspace{4mm} \hbox to 5.78in { {\Large \hfill #5 \hfill} }
        \vspace{2mm} \hbox to 5.78in { {\it #3 \hfill #4} }
        \ifnum\me=0
        \vspace{2mm} \hbox to 5.78in { {\it Collaborators: \collabs
            \hfill} }
        \fi
      } }
  \end{center}
  \vspace*{4mm}
}

\newcounter{pppp}
\newcommand{\prob}{\arabic{pppp}} %problem number
\newcommand{\increase}{\addtocounter{pppp}{1}} %problem number

% Arguments: Title, Number of Points
\newcommand{\newproblem}[2]{
  \ifnum\me=0
    \ifnum\prob>0 \newpage \fi
    \increase
    \setcounter{page}{1}
    \handout{\name{} (\netid), Homework \num, Problem \arabic{pppp}}
    {\today}{Name: \name{} (\netid)}{Due: \due}
    {Solutions to Problem \prob\ of Homework \num\ (#2)}
  \else
    \increase
    \section*{Problem \num-\prob~(#1) \hfill {#2}}
  \fi
}

% \newcommand{\newproblem}[2]{\increase
% \section*{Problem \num-\prob~(#1) \hfill {#2}}
% }

\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}
\def\qed{\hspace*{\fill}
  \vbox{\hrule\hbox{\vrule\squarebox{.667em}\vrule}\hrule}}
\newenvironment{solution}{\begin{trivlist}\item[]{\bf Solution:}}
  {\qed \end{trivlist}}
\newenvironment{solsketch}{\begin{trivlist}\item[]{\bf Solution
      Sketch:}} {\qed \end{trivlist}}
\newenvironment{code}{\begin{tabbing}
    12345\=12345\=12345\=12345\=12345\=12345\=12345\=12345\= \kill }
  {\end{tabbing}}

%\newcommand{\eqref}[1]{Equation~(\ref{eq:#1})}

\newcommand{\hint}[1]{({\bf Hint}: {#1})}
% Put more macros here, as needed.
\newcommand{\room}{\medskip\ni}
\newcommand{\brak}[1]{\langle #1 \rangle}
\newcommand{\bit}[1]{\{0,1\}^{#1}}
\newcommand{\zo}{\{0,1\}}
\newcommand{\C}{{\cal C}}

\newcommand{\nin}{\not\in}
\newcommand{\set}[1]{\{#1\}}
\renewcommand{\ni}{\noindent}
\renewcommand{\gets}{\leftarrow}
\renewcommand{\to}{\rightarrow}
\newcommand{\assign}{:=}

\newcommand{\AND}{\wedge}
\newcommand{\OR}{\vee}

\newcommand{\For}{\mbox{\bf for }}
\newcommand{\To}{\mbox{\bf to }}
\newcommand{\Do}{\mbox{\bf do }}
\newcommand{\If}{\mbox{\bf if }}
\newcommand{\Then}{\mbox{\bf then }}
\newcommand{\Else}{\mbox{\bf else }}
\newcommand{\While}{\mbox{\bf while }}
\newcommand{\Repeat}{\mbox{\bf repeat }}
\newcommand{\Until}{\mbox{\bf until }}
\newcommand{\Return}{\mbox{\bf return }}
\newcommand{\Halt}{\mbox{\bf halt }}
\newcommand{\Swap}{\mbox{\bf swap }}
\newcommand{\Ex}[2]{\textrm{exchange } #1 \textrm{ with } #2}



\begin{document}

\ifnum\me=0


\fi

\ifnum\me=1

\handout{PS \num}{\today}{Lecturer: Yevgeniy Dodis}{Due: \due}
{Solution {\em Sketches} to Problem Set \num}

\fi

\ifnum\me=2

\handout{PS \num}{\today}{Lecturer: Yevgeniy Dodis}{Due: \due}{Problem
  Set \num}

\fi


\newproblem{Integer Multiplication} {5 points}

\noindent
Let $n$ be a multiple of $m$.  Design an algorithm that can multiply an
$n$-bit integer with an $m$-bit integers in time
$O(n m^{\log_2 3 - 1})$.

\ifnum\me<2
\begin{solution} \\

	Assuming that taking the log of a given n-bit integer is a constant cost:
	\begin{code}
	  \>{\sc Multiply}$(a, b)$:\\
	  \> \> first = $log(a)/log(2)$ \\
	  \> \> second = $log(b)/log(2)$ \\
	  \> \> s = $first + second$ \\
	  \> \> \Return $2^s$
	\end{code}
\end{solution}
\fi

\newproblem{Trominoes}{10 points}

\noindent
An $n$-tromino is a $2^n \times 2^n$ ``chessboard of unit squares with
one corner removed'' (figure below drawn for $n = 3$). Assume that
initially you are given a $1$-tromino (i.e., a simple $L$-shaped tile
of area $3$ drawn on the right), but you have a friendly genie whom
you can ask to perform the following two operations in any order:


%\begin{comment}
\begin{table}[ht]
\hspace{0.5cm}
\begin{minipage}[b]{1\linewidth}\centering
\begin{itemize}
\item {\sc Duplicate}: This operation takes an object as input, and
  creates a second identical copy of this object.
\item {\sc Glue}: This operation takes two objects as input, and
  glues them together (along the sides, without any overlaps) in a
  manner specified by you.
\end{itemize}
\end{minipage}
\hspace{0.5cm}
%\begin{minipage}[b]{0.45\linewidth}\centering
%\vspace*{-3ex}
%\includegraphics{pic5.eps}
%\end{minipage}
\end{table}
%\end{comment}



\begin{itemize}
  \item[(a)] (6 points) Design a recursive algorithm {\sc
    Tromino}$(n)$ that creates an $n$-tromino from $1$-tromino using
  the a minimum number of calls to the genie. You only need to specify
  the top level of the recursion, without the need to explicitly
  ``unwind'' the recursion all the way to $n=1$. \hint{First step is
    to {\sc Duplicate} the original $1$-tromino, as otherwise you
    ``lose'' it in the recursive call(s), and you might need it in the
    ``conquer'' step.}  \ifnum\me<2
\begin{solution}
	\begin{code}
	  totalSquares = (perimeter+1)/2\\
	  extraTrominoes = 0;
	  {\sc Tromino}$(n)$:\\
	  \> \If $2^n$ != totalSquares and tromino.count == 1:\\
	  \> \> extraPiece = {\sc Duplicate} x 1\\ 
	  \> \> {\sc Duplicate} x 4\\
	  \> \> {\sc Glue} so that 1 tromino its corner meeting the inside of the original tromino and the other 3\\
	  \> \> with their insides angle being filled with original tromino corner.\\	   
	  \> \> \If $2^n$ == totalSquares:\\\
	  \> \> \> \Return;\\
	  \> \> \Else: extraPieces = {\sc Duplicate}(extraPiece) x $(2^n)/3$ \\
	  \> \> \> {\sc Tromino}$(n)$\\  
	  
	  \> \Else \If $2^n$ != totalSquares and tromino.count $>$ 1:\\
	  \> \> {\sc Duplicate} x 3 \\

	  \> \>{\sc Glue} the 4 pieces together so that 3 of the missing corners are pointed inwards and\\
	  \> \> one of the missing corners is pointed outwards, forming a tromino of negative space.\\ \\

	  	  
	  \> \> \If $2^n$ == totalSquares:\\
	  \> \> \> \Return;\\
	  \> \> \Else: {\sc Tromino}$(n)$\\ 
	  \> \Else:\\
	  \> \> Use the previously calculated extra pieces to fill in trominoes where there are\\\>\>spaces for them with {\sc Glue}.
	\end{code}
\end{solution}
  \fi

  \item[(b)] (4 points) Give a recurrence relation for the number of
  calls $T(n)$ to the genie, and solve it.  \ifnum\me<2
\begin{solution}
	\begin{code}
	$T(n) = n*T(n) + 8$ \\
	\> $= n*T(n) + 8n^k + 8n^{k-1}$ .. \\
	\> $= n*T(n) + \sum\limits_{i=0}^n 8n^{k-i} $\\
	\end{code}
\end{solution}
  \fi
\end{itemize}

\newproblem{Rotation-Sorted Arrays}{12 points}

\noindent
An array $A[0\ldots (n-1)]$ is called {\em rotation-sorted} if there
exists some some cyclic shift $0\le c< n$ such that
$A[i] = B[(i+c \bmod n)]$ for all $0\le i<n$, where $B[0\ldots (n-1)]$
is the sorted version of $A$.%
\footnote{Intuitively, $A$ is either completely sorted (if $c=0$), or
  (if $c>0$) $A$ starts in sorted order, but then ``falls off the
  cliff'' when going from $A[n-c-1]=B[n-1]=\max$ to
  $A[n-c]=B[0]=\min$, and then again goes in increasing order while
  never reaching $A[0]$.} %
For example, $A=(2,3,4,7,1)$ is rotation-sorted, since the sorted
array $B = (1,2,3,4,7)$ is the cyclic shift of $A$ with $c=1$ (e.g.
$1=A[4] = B[(4+1) \bmod 5] = B[0]=1$). For simplicity, below let us
assume that $n$ is a power of two (so that can ignore floors and
ceilings), and that all elements of $A$ are distinct.

\begin{itemize}
  \item[(a)] (4 points) Prove that if $A$ is rotation-sorted, then one
  of $A[0\ldots (n/2-1)]$ and $A[n/2 \ldots (n-1)]$ is fully sorted
  (and, hence, also rotation-sorted with $c=0$), while the other is at
  least rotation-sorted. What determines which one of the two halves
  is sorted? Under what condition {\em both halves} of $A$ are sorted?

\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
\fi

\item[(b)] (8 points) Assume again that $A$ is rotation-sorted, but
you are not given the cyclic shift $c$. Design a divide-and-conquer
algorithm to compute the minimum of $A$ (i.e., $B[0]$). Carefully
prove the correctness of your algorithm, write the recurrence equation
for its running time, and solve it. Is it better than the trivial
$O(n)$ algorithm? \hint{Be careful with $c=0$ an $c=n/2$; you might
  need to handle them separately.}

\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
\fi
\end{itemize}


\newproblem{Min-Max using Divide and Conquer} {8 points}

\noindent
Find a {\em divide-and-conquer} algorithm that finds the maximum and
the minimum of an array of size $n$ using at most $3n/2$
\emph{comparisons} (between elements of the array).  (Note that we are
not asking for an iterative algorithm.  We are asking for you to {\em
  explicitly use recursion}.)  Derive an \emph{exact} recurrence for
the number of \emph{comparisons} of your algorithm and prove it using
induction.

\noindent
\hint{Your conquer step should make a constant number of comparisons.
  Be careful for what $n$ you stop recursing.}

\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
\fi



\end{document}


